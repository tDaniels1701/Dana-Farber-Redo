---
title: VLMS - Cancer Surveillance
author: VLMS Team
format:
  html:
    embed-resources: true
  dashboard:
    theme: zephyr
server: shiny
jupyter: python3
---


```{python}
# %pip install sshtunnel
# %pip install sqlalchemy
# %pip install dotenv
# %pip install shinywidgets
# %pip install pymysql
#%pip install --upgrade shinywidgets
import warnings
warnings.filterwarnings('ignore') 
import json

from urllib.request import urlopen
import os
import plotly.graph_objects as go
import geopandas as gpd
import pandas as pd
import plotly.express as px

# from plotly.callbacks import Points
#from sshtunnel import SSHTunnelForwarder
import plotly.figure_factory as ff
#from sqlalchemy import create_engine
#from dotenv import load_dotenv
import os
from shiny.express import input, render, ui
from shinywidgets import render_plotly, render_widget
#import urllib.parse as up
#import pymysql

import plotly.io as pio
pio.renderers.default = "plotly_mimetype+notebook_connected"
#pio.renderers.default = 'plotly_renderer_id'
# load_dotenv()
# ssh_host = "192.168.103.2"
# ssh_user = os.getenv("USER_NAME")
# ssh_password = os.getenv("USER_PASSWORD")

# mysql_host = "192.168.103.5"
# mysql_port = 3306
# mysql_user = "root"
# mysql_password = os.getenv("ROOT_PASSWORD")
# db_name = "CREDO"
# encoded_pw = up.quote_plus(mysql_password)

# # Set up SSH tunnel using password
# server = SSHTunnelForwarder(
#     (ssh_host, 22),
#     ssh_username=ssh_user,
#     ssh_password=ssh_password,
#     remote_bind_address=(mysql_host, mysql_port),
# )

# server.start()

# Build connection to local forwarded port

# local_port = server.local_bind_port
# engine = create_engine(
#     f"mysql+pymysql://{mysql_user}:{encoded_pw}@127.0.0.1:{local_port}/{db_name}"
# )


# def get_data():

#     df = pd.read_sql(
#         f"""SELECT 
# 	CREDO.Record.ID as 'recordID',
#     CREDO.Rotation.description as 'rotationType',
#     CREDO._Gender.descriptor as 'patientSex',
#     CREDO._Age.descriptor as 'patientAge',
#     CREDO.Code.code,
#     CREDO.Code.description as 'codeDescription',
#     CREDO.Code.description,
#     CREDO.Record.dateCreated as 'entryLoggedAt',
#     CREDO.Location.name,
#     CREDO.Location.addressStreetNumber,
# 	CREDO.Location.addressStreetRoute,
# 	CREDO.Location.addressLocality,
# 	CREDO.Location.addressDistrict,
# 	CREDO.Location.addressCounty,
# 	CREDO.Location.addressState,
# 	CREDO.Location.addressCountry,
# 	CREDO.Location.addressPostalCode,
# 	CREDO.Location.addressPostalCodeSuffix,
#     CREDO.Location.addressFormatted,
#     CREDO.Location.geoLongitude,
#     CREDO.Location.geoLatitude
# FROM
#     CREDO.Record
#         INNER JOIN
#     CREDO.Code ON CREDO.Record.codeID = CREDO.Code.ID
#         INNER JOIN
#     CREDO.Patient ON CREDO.Record.patientID = CREDO.Patient.ID
#         INNER JOIN
#     CREDO._Age ON CREDO.Patient.patientAge = CREDO._Age.ID
#         INNER JOIN
# 	CREDO._Gender ON CREDO.Patient.patientGender = CREDO._Gender.ID
#         INNER JOIN
#     CREDO.Location ON CREDO.Record.locationID = CREDO.Location.ID
#         INNER JOIN
#     CREDO.Rotation ON CREDO.Record.rotationID = CREDO.Rotation.ID
# WHERE
#     CREDO.Code.code LIKE 'C%%' and CREDO.Code.type = 1
# ORDER BY CREDO.Record.dateCreated ASC;

#     """,
#         engine,
#     )

#     return df


# data = get_data()
# data.to_csv('cancer_data.csv')
CENSUS_DATA_PATH = r"census-data\state_and_county_fips_master.csv"
# PROCESS DATA
county_list = [
    "Tazewell County",
    "Chesapeake",
    "Galax City County",
    "Hampton City County",
    "Lynchburg City County",
    "Manassas City County",
    "Newport News City County",
    "Norfolk City County",
    "Portsmouth City County",
    "Radford City County",
    "St. Louis City County",
    "Staunton City County",
    "Virginia Beach City County",
    "District of Columbia County",
]

rotation_drop = [
    "Standardized Patient",
    "Clinical Procedural Skills",
    "High Fidelity Simulation",
    "Anatomy Lab (OMS I)",
    "CREDO Development",
]


######### Read CSV DATA ########################

#df = data
df = pd.read_csv('cancer_data.csv')
data = df
fips = pd.read_csv(CENSUS_DATA_PATH, names=["fips", "addressCounty", "addressState"])

get_localities = (
    df[["addressLocality", "addressCounty", "addressState"]][
        ~df["addressCounty"].isna()
    ]
    .dropna()
    .drop_duplicates()
)

################## Clean VLMS ####################

get_nan_localities = (
    df[["addressLocality", "addressState"]][df["addressCounty"].isna()]
    .dropna()
    .drop_duplicates()
)


local_rep = get_localities[
    get_localities["addressLocality"].isin(list(get_nan_localities["addressLocality"]))
]

list_mia = sorted(
    list(
        set(get_nan_localities["addressLocality"])
        - set(list(local_rep["addressLocality"]))
    )
)


county_mia = get_nan_localities[
    get_nan_localities["addressLocality"].isin(list_mia)
].sort_values(
    by="addressLocality"
)  # type: ignore

county_mia["addressCounty"] = county_list


county_replacement = pd.concat([county_mia, local_rep])
df.fillna(county_replacement["addressCounty"])

result = pd.merge(
    df, county_replacement, how="left", on=["addressLocality", "addressState"]
)
result["addressCounty_x"] = result["addressCounty_x"].fillna(result["addressCounty_y"])
result.drop(["addressCounty_y"], inplace=True, axis=1)
result.rename(columns={"addressCounty_x": "addressCounty"}, inplace=True)
result = result.drop_duplicates(subset="recordID", keep="first")
result = result.dropna(subset=["geoLongitude"])
result_sorted = result.sort_values("entryLoggedAt")
result_sorted["entryDate"] = (
    result_sorted["entryLoggedAt"].astype(str).str.split().str[0]
)
new_df = result_sorted[~result_sorted["rotationType"].isin(rotation_drop)]

####################summary######################
summary = new_df.groupby(
    ["entryDate", "code", "codeDescription", "addressCounty"], as_index=False
)["code"].value_counts()
# summary.to_csv("County Counts Cancer Dated.csv", index=False)
summary_county = new_df.groupby(
    [
        "code",
        "codeDescription",
        "addressCounty",
        "addressState",
        "patientAge",
        "patientSex",
    ],
    as_index=False,
)["code"].value_counts()
# summary_county.to_csv("County Counts Cancer.csv", index=False)

###############Clean Fips###########
fips["addressCounty"] = fips["addressCounty"].str.replace("city", "City County")
fips["addressCounty"] = fips["addressCounty"].str.replace(
    "Anchorage Municipality", "Anchorage"
)
fips["addressCounty"] = fips["addressCounty"].str.replace(
    "District of Columbia", "District of Columbia County"
)

######### Final Data ###########
final = pd.merge(new_df, fips, how="left", on=["addressCounty", "addressState"])
final.loc[
    (final["addressLocality"] == "Danville") & (final["addressState"] == "VA"),
    "addressCounty",
] = final.loc[
    (final["addressLocality"] == "Danville") & (final["addressState"] == "VA"),
    "addressCounty",
].fillna(
    "Danville City County"
)
final.loc[
    (final["addressLocality"] == "Danville") & (final["addressState"] == "VA"), "fips"
] = final.loc[
    (final["addressLocality"] == "Danville") & (final["addressState"] == "VA"), "fips"
].fillna(
    "51590"
)
final.loc[
    (final["addressLocality"] == "Bristol") & (final["addressState"] == "VA"),
    "addressCounty",
] = final.loc[
    (final["addressLocality"] == "Bristol") & (final["addressState"] == "VA"),
    "addressCounty",
].fillna(
    "Bristol City County"
)
final.loc[
    (final["addressLocality"] == "Bristol") & (final["addressState"] == "VA"), "fips"
] = final.loc[
    (final["addressLocality"] == "Bristol") & (final["addressState"] == "VA"), "fips"
].fillna(
    "51520"
)
final[["addressLocality", "addressState"]][
    final["fips"].isna() & ~final["addressCountry"].isna()
].drop_duplicates()

final_us = final[~final["addressCountry"].isna()]
final_us_complete = final_us[~final_us["fips"].isna()]
summary_county = final_us_complete.groupby(
    ["fips", "addressCounty", "addressState"], as_index=False
)["fips"].value_counts()
# summary_county.to_csv("County Counts Cancer Final US.csv", index=False)
summary_county_by_cancer = final_us_complete.groupby(
    ["fips", "code", "codeDescription", "addressCounty", "addressState"], as_index=False
)["code"].value_counts()
# summary_county_by_cancer.to_csv("County Counts by Cancer Final US.csv", index=False)
summary_all = (
    summary_county_by_cancer.pivot_table(
        index=["fips", "addressCounty", "addressState"],
        columns="code",
        values="count",
        aggfunc="first",
    )  # type: ignore
    .reset_index()
    .fillna(0)
)
summary_all["Total"] = summary_all.iloc[:, 4:].sum(axis=1)

summary_all.sort_values(by="Total", ascending=False)

col_nam = list(summary_all.iloc[:, 4:-1].columns)
cancer_group = set([e.split(".")[0] for e in col_nam])

# with open("processed-data\cancer_group.csv", "w", encoding="utf-8", newline="") as csvfile:  # type: ignore
#     writer = csv.writer(csvfile)
#     writer.writerow(cancer_group)

for i in cancer_group:
    filter_group = summary_all.iloc[:, 4:].filter(regex=i)
    summary_all[f"{i}" + " Total"] = filter_group.sum(axis=1)
# summary_all.to_csv("County Counts by Cancer Final US.csv", index=False)

summary_totals = pd.concat(
    [summary_all.iloc[:, :3], summary_all.iloc[:, (summary_all.shape[1] - 15) :]],
    axis=1,
)
summary_totals["fips"] = summary_totals["fips"].apply(
    lambda x: "0" + x if len(x) <= 4 else x
)
# summary_totals.to_csv('County Counts by Cancer Final US.csv', index =False)

final["parent code"] = final[["code", "codeDescription"]]["code"].str.split(".").str[0]

cancer_name_map = final[["parent code", "codeDescription"]][
    final["parent code"] == final["code"]
].drop_duplicates()

cancer_name_map.loc[-1] = [
    "C93",
    "Chronic myelomonocytic leukemia (CMML) that has not achieved remission",
]
cancer_name_map.loc[-2] = ["C54", "Malignant neoplasm of the corpus uteri"]
cancer_name_map = cancer_name_map[
    cancer_name_map["parent code"].str.len() == 3
].sort_values(by="parent code")
# cancer_name_map.to_csv("processed-data\cancer_name_map.csv", index=False)  # type: ignore

final_us_complete["parent code"] = (
    final_us_complete[["code", "codeDescription"]]["code"].str.split(".").str[0]
)
final_us_complete["year"] = final_us_complete["entryDate"].str.split("-").str[0]
sex_summary = (
    final_us_complete.groupby(["year", "parent code"], as_index=False)["patientSex"]
    .value_counts()
    .pivot_table(
        index=["year", "parent code"],
        columns="patientSex",
        values="count",
        aggfunc="first",
    )  # type: ignore
    .reset_index()
    .fillna(0)
)
age_summary = final_us_complete.groupby(["year", "parent code"], as_index=False)[
    "patientAge"
].value_counts()
# summary_date = final_us_complete.groupby(['year', 'parent code', 'codeDescription',
# 'fips','addressCounty','addressState'], as_index=False)['parent code'].value_counts()
# summary_date.to_csv('County Counts Cancer Dated.csv', index =False)

summary_date = final_us_complete.groupby(
    ["year", "parent code", "fips", "addressCounty", "addressState"], as_index=False
)["parent code"].value_counts()
# summary_date.to_csv("processed-data\summary_date.csv", index=False)  # type: ignore

summary_date_all = (
    summary_date.pivot_table(
        index=["year", "fips", "addressCounty", "addressState"],
        columns=["parent code", "year"],
        values="count",
        aggfunc="first",
    )  # type: ignore
    .reset_index()
    .fillna(0)
)

sex_summary["percentage"] = sex_summary["Female"] / (
    sex_summary["Female"] + sex_summary["Male"]
)

age_summary = pd.merge(age_summary, sex_summary, how="left", on=["year", "parent code"])

age_summary = final_us_complete.groupby(
    ["year", "parent code", "patientSex"], as_index=False
)["patientAge"].value_counts()
# age_summary.to_csv("processed-data\demographic_summary.csv", index=False)
cancer_centers = gpd.read_file(
    "NCI_CancerCenter_Address_fall2024/NCI_CancerCenter_Address_fall2024.shp"
)
# Initialize app
with urlopen(
    r"https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json"
) as response:
    counties = json.load(response)
data["entryLoggedAt"] = pd.to_datetime(data["entryLoggedAt"])    
YEARS = sorted(data["entryLoggedAt"].dt.year.astype(str).unique())
DATA_LIST = ["cancer_name_map", "cancer_group", "summary_date", "demographic_summary"]

p = os.getcwd().split(os.path.sep)
cancer_name_map = cancer_name_map
cancer_name_map = cancer_name_map.sort_values("parent code")
cancer_group = cancer_group
demographic_summary = age_summary
POP_PATH = r"census-data/PopulationEstimates.csv"
pop = pd.read_csv(POP_PATH, engine="python", encoding="latin1")
POV_PATH = r"census-data/PovertyEstimates.csv"
poverty = pd.read_csv(POV_PATH)
EMP_PATH = r"census-data/Unemployment.csv"
employ = pd.read_csv(EMP_PATH)
IND_PATH = r"census-data/CBP2022.CB2200CBP-Data.zip"
industry_data = pd.read_csv(
    IND_PATH, header=0, compression="zip", low_memory=False
).drop(0, axis=0)

industry_data["fips"] = industry_data["GEO_ID"].str.split("US").str[1]
industry_data.drop(["PAYANN_N", "PAYQTR1_N", "EMP_N"], axis=1, inplace=True)
industry_actual = industry_data[industry_data["PAYANN"] != "N"]
industry_county_max = industry_actual.groupby(["fips", "NAME", "NAICS2017_LABEL"])[
    ["ESTAB", "PAYANN", "EMP"]
].max()
FEM_PATH = r"census-data/female demographic totals.csv"
female_pop = pd.read_csv(FEM_PATH)
female_pop["FIP"] = (
    female_pop["FIP"].astype(str).apply(lambda x: "0" + x if len(x) <= 4 else x)
)
MALE_PATH = r"census-data/male demographic totals.csv"
male_pop = pd.read_csv(MALE_PATH)
male_pop["FIP"] = (
    male_pop["FIP"].astype(str).apply(lambda x: "0" + x if len(x) <= 4 else x)
)
pop["year"] = pop["Attribute"].str.split("_").str[-1]
poverty["year"] = poverty["Attribute"].str.split("_").str[-1]
employ["year"] = employ["Attribute"].str.split("_").str[-1]

summary_date["fips"] = (
    summary_date["fips"].astype(str).apply(lambda x: "0" + x if len(x) <= 4 else x)
)
pop["FIPStxt"] = (
    pop["FIPStxt"].astype(str).apply(lambda x: "0" + x if len(x) <= 4 else x)
)
poverty["FIPS_Code"] = (
    poverty["FIPS_Code"].astype(str).apply(lambda x: "0" + x if len(x) <= 4 else x)
)
employ["FIPS_Code"] = (
    employ["FIPS_Code"].astype(str).apply(lambda x: "0" + x if len(x) <= 4 else x)
)


CANCER_CENTER = r"processed-data/cancer centers.xlsx"
cancer_cent = pd.read_excel(CANCER_CENTER)
cancer_cent["type"] = cancer_cent["type"].str.replace("RADIOIO", "Radiology Only")
cancer_cent["type"] = cancer_cent["type"].str.replace("RADIO", "Radiology Only")
cancer_cent["type"] = cancer_cent["type"].str.replace("CHEMO", "Chemotherapy Only")
cancer_cent["type"] = cancer_cent["type"].str.replace("BOTH", "Chemo and Radiology")
cancer_cent["type"] = cancer_cent["type"].str.replace(
    "TREAT", "Cancer Treatment Center"
)
cancer_centers["type"] = "NCI " + cancer_centers["type"]
TABLE_LIST = [
    "Employment",
    "Industry",
    "Population",
    "Poverty",
    "Female Race/Ethnicity By Age Ranges",
    "Male Race/Ethnicity By Age Ranges",
]
AGE_GROUP_LIST = [
    "Infant",
    "Neonate",
    "1-14",
    "14-18",
    "19-44",
    "45-64",
    "65-84",
    "85+",
];
##
```

```{python}
ui.input_dark_mode() 
##
```

```{python}

ui.input_select(
    "cancer",
    "Select Cancer Diagnosis",
    choices=cancer_name_map["codeDescription"] + " - " + cancer_name_map["parent code"],
    )
@render.text 
def get_cancer():
    return f"{input.cancer()}"
###

```

###

```{python}
ui.input_select("table", "Select Table", choices=TABLE_LIST)
@render.text 
def get_table():
    return f"{input.table()}"
```

###

```{python}
ui.input_select(
    "year",
    "Select Year",
    choices=YEARS,
    )
@render.text 
def get_year():
    return f"{input.year()}"
```

##

```{python}
def summary_df():
    return summary_date 
summary_df()
###
```

##

```{python}
@render_plotly
def create_geoplot():
    """Create Choropleth Visualization"""
    code = input.cancer().split(" - ")[-1]
    print(code)
    year = input.year()
    cancer_name = input.cancer().split(" - ")[0]
    value = "count"

    df = summary_date[summary_date["parent code"] == code]
    df = df[df["year"] == year]
    df["name"] = [cancer_name] * len(df)

    figc = px.choropleth_map(
        df,
        geojson=counties,
        locations="fips",  # Spatial coordinates
        color=value,  # Data to be color-coded
        hover_data={
            "name": True,
            "parent code": True,
            "addressState": True,
            value: True,
            "fips": False,
        },
        labels={
            "name": "Cancer",
            "parent code": "ICD 10",
            "addressState": "State",
            value: "Total Count",
            "year": "Year",
        },
        #animation_frame="year",
        color_continuous_scale="Viridis",
        hover_name="addressCounty",
        map_style="open-street-map",
        zoom=6,
        center={"lat": 34.9496, "lon": -81.9321},
        opacity=0.5,
    ).update_traces(visible=True)

    figc.update_layout(
        title=f"{code} - {cancer_name}",
        coloraxis_colorbar=dict(
            yanchor="top",
            y=1,
            # len=0.75,
            x=-0.05,
            #bgcolor="#171b26",
            ticklabelposition="outside left",
            ticks="outside",
            # ticksuffix=" counts",
        ),
    )


    # figc.update_layout(
    #     dict(
    #         font=dict(color="black"),
    #         legend=dict(
    #             title="Cancer Center Classifications",
    #             yanchor="top",
    #             #bgcolor="#171b26",
    #             y=0.99,
    #             xanchor="right",
    #             x=0.1,
    #             itemsizing="constant",
    #         ),
    #     )
    # )

    #w = go.FigureWidget(figc.data, figc.layout)

    #w.data[0].on_hover(on_point_hover)
    #figc.show()
    return figc#, w

def create_geoplot():
    """Create Choropleth Visualization"""
    code = 'C18'
    year = '2024'
    cancer_name = 'Colon'
    value = "count"

    df = summary_date[summary_date["parent code"] == code]
    df = df[df["year"] == year]
    df["name"] = [cancer_name] * len(df)

    figc = px.choropleth_map(
        df,
        geojson=counties,
        locations="fips",  # Spatial coordinates
        color=value,  # Data to be color-coded
        hover_data={
            "name": True,
            "parent code": True,
            "addressState": True,
            value: True,
            "fips": False,
        },
        labels={
            "name": "Cancer",
            "parent code": "ICD 10",
            "addressState": "State",
            value: "Total Count",
            "year": "Year",
        },
        #animation_frame="year",
        color_continuous_scale="Viridis",
        hover_name="addressCounty",
        map_style="open-street-map",
        zoom=6,
        center={"lat": 34.9496, "lon": -81.9321},
        opacity=0.5,
    ).update_traces(visible=True)

    figc.update_layout(
        title=f"{code} - {cancer_name}",
        coloraxis_colorbar=dict(
            yanchor="top",
            y=1,
            # len=0.75,
            x=-0.05,
            #bgcolor="#171b26",
            ticklabelposition="outside left",
            ticks="outside",
            # ticksuffix=" counts",
        ),
    )


    # figc.update_layout(
    #     dict(
    #         font=dict(color="black"),
    #         legend=dict(
    #             title="Cancer Center Classifications",
    #             yanchor="top",
    #             #bgcolor="#171b26",
    #             y=0.99,
    #             xanchor="right",
    #             x=0.1,
    #             itemsizing="constant",
    #         ),
    #     )
    # )

    #w = go.FigureWidget(figc.data, figc.layout)

    #w.data[0].on_hover(on_point_hover)
    #figc.show()
    return figc
###
@render_plotly
def display_selected_data():
    """Display Demo/Socioeconmic Data"""
    # fig=None
    value = input.table()
    hover_data=True
    if hover_data:
        #county = hover_data["points"][0]["hovertext"]
        #fip = hover_data["points"][0]["customdata"][4]
        county = 'Spartanburg County'
        fip = '45083'
        pop_sc = pop[pop["FIPStxt"] == fip]
        pov_sc = poverty[poverty["FIPS_Code"] == fip]
        employ_sc = employ[employ["FIPS_Code"] == fip]
        colorscale = [[0, "#4d004c"], [0.5, "#f2e5ff"], [1, "#ffffff"]]
        if value == "Employment":
            # fig = get_employment(employ_sc, colorscale)
            df = employ_sc[employ_sc["year"] == "2022"]
            df["Attribute"] = df["Attribute"].str.replace("_", " ")  #
            df["Attribute"] = df["Attribute"].str.rsplit(" ", n=1, expand=True)[0]
            df = df.set_index("Attribute").sort_index()
            fig = ff.create_table(df.iloc[:, 3:], index=True, colorscale=colorscale)
            fig.update_layout(
                title_text=f'Employment Metrics: {df["Area_Name"].iloc[0]} '
            )
            # fig.update_layout({"margin": {"t": 50}})
            for i in range(len(fig.layout.annotations)):
                fig.layout.annotations[i].font.size = 10
            fig.update_layout(
                dict(
                    margin=dict(l=0, r=0, b=0, t=50, pad=0),
                    paper_bgcolor="rgba(0,0,0,0)",
                    # plot_bgcolor="rgba(0,0,0,0)",
                    font=dict(color="white"),
                )
            )
        if value == "Poverty":
            # fig = get_poverty(pov_sc, colorscale)
            df = pov_sc[
                (pov_sc["year"] == "2021") & (pov_sc["Attribute"].str.contains("ALL"))
            ]
            pov_pct = df.iloc[3:, 3:]
            pov_pct["Attribute"] = [
                "Poverty %",
                "90% Conf.<br>Interval Lower",
                "90% Conf.<br>Interval Upper",
            ]
            pov_pct = pov_pct.set_index("Attribute").sort_index()
            fig = ff.create_table(
                pov_pct, index=True, colorscale=colorscale, height_constant=60
            )
            fig.update_layout(title_text=f'Poverty Metrics: {df["Area_name"].iloc[0]} ')
            for i in range(len(fig.layout.annotations)):
                fig.layout.annotations[i].font.size = 12

            fig.update_layout(
                dict(
                    margin=dict(l=0, r=0, b=0, t=50, pad=0),
                    paper_bgcolor="rgba(0,0,0,0)",
                    # plot_bgcolor="rgba(0,0,0,0)",
                    font=dict(color="white"),
                )
            )
        if value == "Industry":
            # fig = get_industry(fip, colorscale, county)
            ind_county = industry_county_max.loc[
                industry_county_max.index.get_level_values(0) == str(fip)
            ]
            ind_list = [e[2] for e in list(ind_county.index)]
            ind_county_new = ind_county.reset_index(drop=True)
            ind_county_new["Industry"] = ind_list
            ind_county_new["Industry"] = ind_county_new["Industry"].str.replace(
                "and", " "
            )
            ind_county_new["Industry"] = ind_county_new["Industry"].str.replace(
                ",", " "
            )
            ind_county_new["Industry"] = (
                ind_county_new["Industry"].str.split(" ").str[0]
            )
            ind_format = ind_county_new.set_index("Industry").sort_index()
            ind_format.columns = ["Establishments", "Annual Payroll", "Employees"]
            fig = ff.create_table(ind_format, index=True, colorscale=colorscale)
            fig.update_layout(title_text=f"Industry: {county}")
            for i in range(len(fig.layout.annotations)):
                fig.layout.annotations[i].font.size = 10
            fig.update_layout(
                dict(
                    margin=dict(l=0, r=0, b=0, t=50, pad=0),
                    paper_bgcolor="rgba(0,0,0,0)",
                    # plot_bgcolor="rgba(0,0,0,0)",
                    font=dict(color="white"),
                )
            )

        if value == "Population":
            # fig = get_population(pop_sc,colorscale)
            df = pop_sc[pop_sc["year"] == "2022"]
            pop_pct = df.iloc[[0, 10, 11, 12, 13, 14, 15], 3:]
            pop_pct["Attribute"] = pop_pct["Attribute"].str.replace("_", " ")
            pop_pct["Attribute"] = pop_pct["Attribute"].str.rsplit(
                " ", n=1, expand=True
            )[0]
            pop_pct["Attribute"] = pop_pct["Attribute"].str.replace("R ", "")
            rename = [e + " RATE" for e in pop_pct["Attribute"] if e != "POP ESTIMATE"]
            pop_pct["Attribute"] = ["POP ESTIMATE"] + rename
            pop_pct["Attribute"] = pop_pct["Attribute"].str.replace(" ", "<br>")
            pop_pct = pop_pct.set_index("Attribute").sort_index()
            fig = ff.create_table(
                pop_pct,
                index=True,
                colorscale=colorscale,
                height_constant=60,
            )
            fig.update_layout(
                title_text=f'Population Metrics: {df["Area_Name"].iloc[0]} '
            )
            for i in range(len(fig.layout.annotations)):
                fig.layout.annotations[i].font.size = 12
            fig.update_layout(
                dict(
                    margin=dict(l=0, r=0, b=0, t=50, pad=0),
                    paper_bgcolor="rgba(0,0,0,0)",
                    # plot_bgcolor="rgba(0,0,0,0)",
                    font=dict(color="white"),
                )
            )
        if value == "Female Race/Ethnicity By Age Ranges":
            # fig = get_demo(female_pop, fip,colorscale, county, value)
            female = female_pop.loc[female_pop["FIP"] == str(fip)]
            female = female.set_index("Age Range VLMS").sort_index()
            female.columns = female.columns.str.replace("_", " ")
            female.columns = female.columns.str.replace("/", " ")
            female.columns = female.columns.str.replace("-", " ")
            female.columns = female.columns.str.replace("TOT", "")
            female.columns = female.columns.str.replace(" ", "<br>")
            fig = ff.create_table(
                female.iloc[:, 3:],
                index=True,
                index_title="Age<br>Range",
                colorscale=colorscale,
                height_constant=60,
            )
            for i in range(len(fig.layout.annotations)):
                fig.layout.annotations[i].font.size = 10
            fig.update_layout(
                title_text=f"Female Race/Ethnicity By Age Ranges:<br> {county}"
            )
            fig.update_layout(
                dict(
                    margin=dict(l=0, r=0, b=0, t=50, pad=0),
                    paper_bgcolor="rgba(0,0,0,0)",
                    # plot_bgcolor="rgba(0,0,0,0)",
                    font=dict(color="white"),
                )
            )
        if value == "Male Race/Ethnicity By Age Ranges":
            # fig = get_demo(male_pop, fip,colorscale, county, value)
            male = male_pop.loc[male_pop["FIP"] == str(fip)]
            male = male.set_index("Age Range VLMS").sort_index()
            male.columns = male.columns.str.replace("_", " ")
            male.columns = male.columns.str.replace("/", " ")
            male.columns = male.columns.str.replace("-", " ")
            male.columns = male.columns.str.replace("TOT", "")
            male.columns = male.columns.str.replace(" ", "<br>")
            fig = ff.create_table(
                male.iloc[:, 3:],
                index=True,
                index_title="Age<br>Range",
                colorscale=colorscale,
                height_constant=60,
            )
            for i in range(len(fig.layout.annotations)):
                fig.layout.annotations[i].font.size = 10
            fig.update_layout(
                title_text=f"Male Race/Ethnicity By Age Ranges:<br> {county}"
            )
            fig.update_layout(
                dict(
                    margin=dict(l=0, r=0, b=0, t=50, pad=0),
                    paper_bgcolor="rgba(0,0,0,0)",
                    # plot_bgcolor="rgba(0,0,0,0)",
                    font=dict(color="white"),
                )
            )
    return fig
##
@render_plotly
def create_bar():
    """Create Bar Plot"""
    code = input.cancer()
    df = demographic_summary[
        (demographic_summary["parent code"] == code)
        & (demographic_summary["patientSex"].isin(["Female", "Male"]))
    ]
    cancer_name = cancer_name_map["codeDescription"][
        cancer_name_map["parent code"] == code.split()[0]
    ].iloc[0]
    fig = px.bar(
        df,
        x="year",
        y="count",
        color="patientAge",
        barmode="group",
        facet_col="patientSex",
        category_orders={
            "patientAge": AGE_GROUP_LIST,
            "patientSex": ["Female", "Male"],
        },
        labels={
            "patientSex": "Sex",
            "patientAge": "Age Range",
            "count": "Total Count",
            "year": "Year",
        },
    ).update_traces(width=0.1)
    fig.update_xaxes(title_text=None)
    fig.for_each_annotation(lambda a: a.update(text=a.text.split("=")[1]))
    fig.update_layout(
        title=f"All Counties Aggregated: {code} - {cancer_name}",
        xaxis=dict(title="", categoryorder="category ascending"),
        yaxis=dict(title="Cancer Counts"),
    )
    fig.add_annotation(
        text="Year: 2017-2025",
        x=0.5,
        y=-0.25,
        xref="paper",
        yref="paper",
        showarrow=False,
        font=dict(size=14),
    )
    fig.update_layout(
        dict(
            # margin=dict(l=0, r=0, b=0, t=0.5, pad=0),
            paper_bgcolor="rgba(0,0,0,0)",
            plot_bgcolor="rgba(0,0,0,0)",
            font=dict(color="white"),
        )
    )
    return fig
```

```{python}
create_geoplot()
```

##

```{python}
# @render_plotly
# def create_comparison(hover_reactive):
#     """Create"""
#     hover_data = hover_reactive
#     #     fig = go.Figure()
#     fip = hover_data["points"][0]["customdata"][4]
#     county = hover_data["points"][0]["hovertext"]
#     df = summary_date[summary_date["fips"] == fip]
#     df = df.merge(cancer_name_map, how="left")
#     fig = px.bar(
#         df,
#         x="year",
#         y="count",
#         color="parent code",
#         color_discrete_sequence=[
#             "violet",
#             "firebrick",
#             "yellowGreen",
#             "orange",
#             "cyan",
#             "hotpink",
#             "lightgreen",
#             "darkolivegreen",
#             "mediumvioletred",
#             "salmon",
#             "dodgerblue",
#             "seashell",
#             "sienna",
#             "slateblue",
#         ],
#         barmode="group",
#         hover_data={
#             "codeDescription": True,
#             "parent code": True,
#             "count": True,
#             "year": True,
#         },
#         labels={
#             "codeDescription": "Cancer Diagnosis",
#             "parent code": "ICD 10",
#             "count": "Total Count",
#             "year": "Year",
#         },
#     ).update_traces(width=0.05)
#     fig.update_layout(
#         title=f"Cancer Diagnosis: {county}",
#         xaxis=dict(title="Year: 2017-2025"),
#     )
#     fig.update_layout(
#         dict(
#             # margin=dict(l=0, r=0, b=0, t=0.5, pad=0),
#             legend=dict(title="ICD 10 Codes"),
#             paper_bgcolor="rgba(0,0,0,0)",
#             plot_bgcolor="rgba(0,0,0,0)",
#             font=dict(color="white"),
#         )
#     )
#     return fig
```

